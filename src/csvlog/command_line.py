import argparse
import logging
from datetime import datetime
from pathlib import Path
from typing import Optional

logging.basicConfig()
logger = logging.getLogger(__name__)


def create_csv_merge_argument_parser() -> argparse.ArgumentParser:
    #  This is the string that determines how the date part of autogenerated directory and filenames.
    #  It's probably easier if those names match the time that the program was run, and not the different times they
    #  happen to be created, so this time is stored once when the program is entered.
    date_name_format_string = '%y%m%d%H%M'
    date_name_component = datetime.now().strftime(date_name_format_string)

    #  This is the string that shows up when the program is invoked with the -h option.
    description = "Combine CSV report files NOT YET IMPLEMENTED"

    # These match the default log levels defined in the logging package in order of severity.
    # NOTSET on the root logger means that all messages will be shown.
    log_levels = "critical error warning info debug notset".upper().split()

    def input_directory_path_type(path: str) -> Path:
        """Ensures that the input directory is a Path to a directory that exists"""
        path_obj = Path(path)
        if not path_obj.is_dir():
            raise argparse.ArgumentTypeError(f"{path} must refer to a directory")
        return path_obj

    def output_file_path_type(path: str) -> Path:
        """Ensures that the output file is a path to a file that does not already exist.
           Uses a time-based default name if none is given."""
        path_obj = Path(path) if path else Path(Path.cwd(), f"{date_name_component}.csv")
        if path_obj.exists():
            raise argparse.ArgumentTypeError("Output file already exists, will not overwrite")
        return path_obj

    def backup_directory_path_type(path: str) -> Optional[Path]:
        """Ensures that if present the backup directory path is a Path object referring to an existing directory"""
        path_obj = Path(path) if path else None
        if path_obj is not None and not path_obj.is_dir():
            raise argparse.ArgumentTypeError("The backup directory must be an existing directory")
        return path_obj

    csv_merge_parser = argparse.ArgumentParser(description=description)
    csv_merge_parser.add_argument("--input-directory", "-i",
                                  help="Input directory, defaults to the current working directory",
                                  type=input_directory_path_type, default=Path.cwd())
    # Note that the default has to be a string so that the type argument will be applied.
    csv_merge_parser.add_argument("--output-file", "-f",
                                  help=" ".join((
                                      "Output file name,",
                                      "defaults to a unique time-based name in the current working directory")),
                                  type=output_file_path_type, default='')
    csv_merge_parser.add_argument("--backup-directory", "-b",
                                  help=" ".join((
                                      "The backup directory, processed files will be moved to a created subdirectory ",
                                      "inside it.  Files will not be moved if this argument is omitted.")),
                                  type=backup_directory_path_type, default="")
    csv_merge_parser.add_argument("--log-level", "-l", choices=log_levels, default="WARN", type=str.upper,
                                  help="Optional logging level")
    return csv_merge_parser


def main():
    parser = create_csv_merge_argument_parser()
    args = parser.parse_args()
    logging.getLogger().setLevel(args.log_level)
    logger.info(args)


if __name__ == "__main__":
    main()
